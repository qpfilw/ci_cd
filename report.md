## Part 1. Настройка gitlab-runner

Поднимем виртуальную машину `Ubuntu Server 22.04 LTS`.

![1.png](image/1.png)
>Версия виртуальной машины

Скачаем и установим на виртуальную машину `gitlab-runner`. Воспользуемся командой `sudo curl -L --output /usr/local/bin/gitlab-runner "https://s3.dualstack.us-east-1.amazonaws.com/gitlab-runner-downloads/latest/binaries/gitlab-runner-linux-amd64"` для скачивания бинарного файла установки GitLab. 

![2.png](image/2.png)
>Скачали бинарный файл

Дадим файлу разрешение на исполнение с помощью выдачи прав командой `sudo chmod +x /usr/local/bin/gitlab-runner`

![3.png](image/3.png)
>Дали права на исполнение файла

Создадим пользователя GitLab

![4.png](image/4.png)
>Создание пользователя GitLab

Установим GitLab как службу с помощью команды `sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner`

![5.png](image/5.png)
>Установка службой

Запустим службу GitLab

![6.png](image/6.png)
>Запуск

Запустим gitlab-runner и зарегистрируем его для использования в текущем проекте (DO6_CICD).

Для этого необходимо ввести данные при регистрации:

Cвой URL-адрес GitLab, указанный в задании на странице `https://edu.21-school.ru`
Cвой регистрационный токен, указанный там же
Название раннера - DO6_CICD
Теги для заданий, разделенные запятыми - в моем случае - build, style, test, deploy
Тип исполнителя - shell

![7.png](image/7.png)
>Запуск и регистрация раннера

## Part 2. Сборка

Напишем этап для CI по сборке приложений из проекта `C2_SimpleBashUtils`. В файле `gitlab-ci.yml` добавим этап запуска сборки через мейк файл из проекта C2. Файлы, полученные после сборки (артефакты), сохраним в произвольную директорию со сроком хранения 30 дней.

![8.png](image/8.png)
>Файл `gitlab-ci.yml`

Однако при пуше возникает ошибка работы файла.

![9.png](image/9.png)
>Ошибка

Данная ошибка возникает, тк конфигурация `gitlab-runner`, по-умолчанию очищает терминал при выходе из оболочки `shell`. Закомментируем строки по пути `/home/gitlab-runner/.bash_logout` для решения данной ошибки.

![10.png](image/10.png)
>Комментирование файла конфигурации

Теперь перезапустим пайплайн и увидим отсутсвие ошибок

![11.png](image/11.png)
![12.png](image/12.png)
>Демонстрация успешной работы

## Part 3. Тест кодстайла

Напишем этап для CI, который запускает скрипт кодстайла (clang-format). Если кодстайл не прошел, то «зафейли» пайплайн. В пайплайне отобразим вывод утилиты clang-format.

Так же отредактируем `gitlab-ci.yml` для внесения этапа. 

![13.png](image/13.png)
>Добавление этапа для стиля

После пуша обновленного пайплайна заметим, что возникла ошибка, тк на нашей системе отсутсвует clang-format. Установим его с помощью команды `sudo apt install clang-format`

![14.png](image/14.png)
>Ошибка по стилю

После успешной установки clang-format и перезапуска раннера, заметим, что пайплайн успешно заработал

![15.png](image/15.png)
>Успешная работа

## Part 4. Интеграционные тесты

Напишем этап для CI, который запускает интеграционные тесты из того же проекта. Запустим этот этап автоматически только при условии, если сборка и тест кодстайла прошли успешно. Если тесты не прошли, то «зафейли» пайплайн. В пайплайне отобразим вывод, что интеграционные тесты успешно прошли / провалились.

Добавим этап для тестов в файл `gitlab-ci.yml`

![16.png](image/16.png)
>Изменение файла

После пуша файла, заметим, что пайплайн запустился отлично.

![17.png](image/17.png)
>Результат работы пайплайна

Так же, отображу, что происход вывод результатов тестов

![18.png](image/18.png)
>Тесты

## Part 5. Этап деплоя

Поднимем вторую виртуальную машину Ubuntu Server 22.04 LTS.

![19.png](image/19.png)

Для начала настроим файлы конфигурации машин на связь друг с другом

![20.png](image/20.png)
>Изменение файла конфига на машине ws1

![21.png](image/21.png)
>Изменение файла конфига на машине ws2

Обязательно принимаем изменения в настройках адаптеров с помощью команды `sudo netplan apply`. Проверим соединение между машинами 

![22.png](image/22.png)

![23.png](image/23.png)

Сгенерируем ssh-ключи для каждой машины с помощью команды `ssh-keygen`

![24.png](image/24.png)
>ws1

Теперь напишем bash-скрипт, который при помощи ssh и scp копирует файлы, полученные после сборки (артефакты), в директорию `/usr/local/bin` второй виртуальной машины.

![25.png](image/25.png)
>Скрипт

Напишем этап для CD, который «разворачивает» проект на другой виртуальной машине. 

>Запустим этот этап вручную при условии, что все предыдущие этапы прошли успешно.

![26.png](image/26.png)
>Дополнение файла `gitlab-ci.yml` новым этапом

Этап деплоя описан таким образом, что для получения доступа к удаленному серверу применяется ssh-агент. Для его работы необходимо будет выполнить определенный ряд действий

- Настройка ssh-агента
Изменения будут происходить от суперпользователя, поэтому сразу же перейдем в этот режим на ws1 с помощью команды `sudo su`

Перейдем в настройки раннера и обозначим ему где искать ssh-агента. Для этого в файле конфигураций добавим строку `environment = ["SSH_AUTH_SOCK=/tmp/ssh-agent"]`

![27.png](image/27.png)

Далее необходимо сохранить отпечаток удаленного сервера. Для этого ключ удаленного сервера необходимо добавить в файл `known_hosts` в домашнем каталоге пользователя `gitlab-runner`

![28.png](image/28.png)

Так как раннеру необходим приватный ключ, для того, чтобы не возникало проблем с ключами доступа к директории `/home/kylalayl/.ssh` и ее содержимому - скопируем закрытый ключ также в домашний каталог пользователя `gitlab-runner`. Выполним это с помощью команды `cp /home/kylalayl/.ssh/id_rsa /home/gitlab-runner/.ssh/`

![29.png](image/29.png)

Выйдя из режима суперпользователя, скопируем содержимое нашего открытого ssh-ключа на удаленный сервер с помощью команды `ssh-copy-id kylalayl@10.10.0.1`

![30.png](image/30.png)

Теперь запушим все это на ветку и проверим работоспособность пайплайна. Как можем заметить, пайплайн успешно отработал

![31.png](image/31.png)
>Корректная работа пайплайна

## Part 6. Дополнительно. Уведомления

Настроим уведомления об успешном/неуспешном выполнении пайплайна через бота с именем `kylalayl DO6_CI/CD` в Telegram.
Текст уведомления должен содержать информацию об успешности прохождения как этапа CI, так и этапа CD.

Найдем в телеграме через поиск `BotFather`. Это бот для создания других ботов в телеграме. Введем команду `/newbot` и введем название нашего бота `kylalayl DO6_CI/CD`

![32.png](image/32.png)
>Создание бота. На скриншоте видим, что нам выслали API бота. По этому API мы будем настраивать работу бота. 

Найдем другого бота в телеграме под наззванием `getmyid_bot` для понимания нашего IP.

![33.png](image/33.png)

Напишем скрипт, в котором опишем логику работы нашего бота

![34.png](image/34.png)
>Скрипт бота

Работа скрипта проходит успешно

![35.png](image/35.png)
>Работа бота





